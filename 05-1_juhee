# 5부 -1  아키텍처

소프트웨어 시스템의 아키텍처란 시스템을 구축했던 사람들이 만들어낸 시스템의 형태.

그 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수되도록 만들어진다.

아키텍처는 시스템이 제대로 동작하도록 지워하는 데 아무런 역할을 하지 않는 것은 아니지만 동작과 직접적인 연관이 있는 것은 아니다.

- 개발 : 개발하기 힘든 시스템이라면 수명이 길지도 않고 건강하지도 않을 것이다.
- 배포 : 배포 비용이 높을수록 시스템의 유용성은 떨어진다.
- 운영 : 운영에서 겪는 대다수의 어려움은 소프트웨어 아키텍처에는 극적인 영향을 주지 않고도 단순히 하드웨어를 더 투입해서 해결할 수 있다. 시스템 아키텍처가 개발자에게 시스템의 운영방식을 잘 드러내준다고 할 수 있다.
- 유지보수 : 주의를 기울여 신중하게 아키텍처를 만들면 이 비용을 크게 줄일 수 있다.

### 소프트웨어 시스템의 두 구성요소

정책 요소는 모든 업무 규칙과 업무 절차를 구체화 한다.

세부사항에는 입출력 장치, 데이터 베이스, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등이 있다.

아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 데 있다. 

- 고수준의 정책은 어떤 데이터베이스를 쓸 것인지 웹서버를 쓸 것인지와 같은 세부사항에 의존해서는 안된다.
- 뛰어난 아키텍트라면 이러한 결정이 아직 내려지지 않은 것처럼 행동, 여전히 결정을 가능한 한 오랫동안 연기하거나 변경할 수 있는 형태로 시스템을 만든다.
- 좋은 아키텍트는 결정되지 않은 사항의 수를 최대화 한다.

## 독립성

> 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다. 

- 콘웨이의 법칙-
> 

많은 팀으로 구성되며 관심사가 다양한 조직에서 어떤 시스템을 개발해야 한다면, 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여 개발하는 동안 팀들이 서로를 방해하지 않아야 한다. 이를 위해서는 아키텍처가 서로 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 한다.

### How to keep 독립성

1. 계층 결합 분리 : 시스템을 서로 결합되지 않은 수평적인 계층으로 분리 가능
    1. UI, 애플리케이션에 특화된 업무 규칙, 애플리케이션과는 독립적인 업무 규칙, 데이터 베이스
2. 유스케이스 결합 분리 : 수평적으로 잘라놓은 업무를 다시 수직적으로 나누는 역할
    1. 주문 추가, 주문 삭제, 등
    
![스크린샷 2024-11-06 오전 9.27.29.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e7e3a494-c9bc-488f-a428-73865d224a42/b38a7808-8818-42ec-b619-da715794017f/53d8f61a-d565-4f8c-972b-01ebf5fe847c.png)    

<aside>
💡우발적 중복을 주의하자

유스케이스를 수직으로 분리할 때 이러한 문제와 마주치기 쉽상이다. 우리는 유스케이스를 통합하고 싶다는 유혹을 받게 된다. 하지만 추후에 서로 다른 방향으로 분기하며 서로 다른 모습을 가질 가능성이 농후하다. 이것은 가짜 중복으로 계층 간 결합을 적절하게 분리하는 일이 중요하다.

</aside>

- 소스 수준 분리 모드 : 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 만듦
- 배포 수준 분리 모드 : jar파일, DLL, 공유 라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어할 수 있다. 한 모듈의 소스코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 o
- 서비스 수준 분리 모드 : 의존하는 수준을 데이터 구조 단위까지 낮출 수 있다. 순전히 네트워크 패킷을 통해서만 통신하도록 만들 수 있다.

→ 서비스 수준의 분리 모드를 지향하는 것이 올바른 것처럼 보인다. 더 이상의 분리가 필요없는 모델이며 결합으로만 열려 있다. 하지만 이 작업에는 너무 많은 노력이 든다.

→ 컴포넌트 결합을 분리하되 서비스가 되기 직전에 멈추는 방식을 선호, 그러고는 컴포넌트들을 가능한 한 오래 동일한 주소 공간에 남겨둔다. 이를 통해 서비스에 대한 선택권을 열어둘 수 있다.

좋은 아키텍처는 모노리틱구조와 마이크로 서비스 수준 사이의 변경이 용이해야하며 소스코드를 보호할 수 있어야 한다. 

## 경계: 선긋기

> 좋은 아키텍처는 어떤 세부적인 결정에 의존하지 않는다. 좋은 시스템 아키텍처는 이러한 결정을 가능한 한 최후의 순간에 내릴 수 있게 해준다. 결정에 따른 영향이 크지 않다는 것.
> 

GUI는 업무 규칙과는 다른 시점에 다른 속도로 변경되므로, 둘 사이에는 반드시 경계가 필요하다. 업무 규칙은 의존성 주입 프레임워크와는 다른 시점에 그리고 다른 이유로 변경되므로, 둘 사이에도 반드시 경계가 필요하다. → 단일 책임 원칙은 어디에 경계를 그어야 할 지 알려줌.

### 경계선 긋는 법

- 시스템을 컴포넌트 단위로 분할해야한다.
- 일부 컴포넌트는 핵심 업무 규칙에 해당한다. 나머지 컴포넌트는 플러그인으로 핵심업무와는 직접적인 연관 없지만 필수 기능 포함.
- 컴포넌트 사이의 화살표가 특정 방향, 즉 핵심 업무를 향하도록 이들 컴포넌트의 소스를 배치한다.
- 의존성 화살표는 저수준 세부사항에서 고수준의 추상화를 향하도록 배치.

### Why 경계선이 필요한가.

> 소스 코드 모듈 하나가 변경되면, 이에 의존하는 다른 소스코드 모듈도 변경될 수 있다.
다시 컴파일해서 재배포해야하는 상황에 놓일 수 있다…
> 

소프트웨어 시스템이랑 정책을 기술한 것이다.

수준은 입력과 출력까지의 거리다.

고수준은 입출력과 거리가 먼 것.

저수준은 입출력과 거리가 가까운 것.

### 업무규칙

업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙

핵심 규칙과 핵심 데이터는 본질적으로 결합되어 있기 때문에 객체로 만들기 용이 → 엔티티

- 엔티티  - 고수준
    - 컴퓨터 시스템 내부의 객체
    - 핵심 업무 데이터를 직접 포함하거나 핵심 업무 데이터에 매우 쉽게 접근 가능.
- 유스케이스 - 저수준
    - 애플리케이션에 특화된 규칙을 설명
    - 이를 통해 사용자와 엔티티 사이의 상호작용을 규정
    - 유스케이스는 객체
    - 유스케이스는 엔티티를 알지만, 엔티티는 유스케이스를 모름.

→ 엔티티는 고수준이고, 유스케이스는 저수준인 이유:

유스케이스는 단일 애플리케이션에 특화되어 있으며, 따라서 해당 시스템의 입력과 출력에 보다 가깝게 위치하기 때문이다. 엔티티는 수많은 다양한 애플리케이션에서 사용될 수 있도록 일반화된 것이므로, 각 시스템의 입력이나 출력에서 더 멀리 떨어져 있다.

![스크린샷 2024-11-22 오전 10.25.38.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e7e3a494-c9bc-488f-a428-73865d224a42/0188d4fd-7ad4-40bb-ad4e-c993c27c51ef/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-22_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.25.38.png)

### 의존성

- 소스코드 의존성은 반드시 안쪽으로 향해야 한다.

### 엔티티

> 엔티티는 해당 어플리케이션의 업무 객체..?
> 

사실 이 부분이 의아한 부분. 엔티티는 db에 접근하는 클래스, 도메인과는 분리될 필요성이 있다.


# 5부 - 1 읽고 느낀점
엔티티가 곧 도메인을 의미한다고 생각하는 사람들이 많은데 이것은 분리될 필요가 있어 보인다. 도메인 비즈니스 로직과  db 나 입출력 장치 http 통신과 같은 외부의 접근은 내부와 분리되는 것이 더욱 변경이 용이하고 미래가치가 있는 코드일 것이다.
