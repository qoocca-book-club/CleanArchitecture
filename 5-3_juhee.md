### 테스트를 고려한 설계

테스트가 지닌 극단적인 고립성이 테스트는 대체로 배포하지 않는다는 사실과 어우러지며, 개발자는 종종 테스트가 시스템의 설계 범위 밖에 있다고 여긴다. 이 관점은 치명적이다. 테스트가 시스템의 설계와 잘 통합되지 않으면, 테스트는 깨지기 쉬워지고, 시스템은 뻣뻣해져서 변경하기가 어려워진다.

- 변동성이 있는 것에 의존하지 말라.
- GUI를 통한 테스트는 깨지기 쉽다. 의존하지 않는 테스트 만들기.
- 테스트 API가 지닌 강력한 힘을 운영 시스템에 배포하면 보안 위험에 처할 수 있다.
- 테스트는 시스템의 일부다.

> 소프트웨어는 닳지 않지만, 펌웨어와 하드웨어는 낡아가므로 결국 소프트웨어도 수정해야한다.
> 

> 소프트웨어는 닳지 않지만, 펌웨어와 하드웨어에 대한 의존성을 관리하지 않으면 안으로부터 파괴될 수 있다.
> 

기존의 펌웨어 정의

- 펌웨어는  ROM, EPROM 혹은 플래시 메모리 같은 비휘발성 메모리에 유지된다.
- 펌웨어는 하드웨어 장치에 프로그래밍된 소프트웨어 프로그램 혹은 명령어 집합이다.
- 펌웨어는 개별 하드웨어에 내장되는 소프트웨어이다.
- 펌웨어는 읽기전용 메모리에 쓰여진 소프트웨어(프로그램이거나 데이타)이다.

<aside>
💡

펌웨어를 수없이 양산하는 일을 멈추고, 코드에게 유효수명을 길게 늘릴 수 있는 기회를 주어라.

소프트웨어와 펌웨어 사이의 경계를 명확히 해라.

</aside>

| 소프트웨어 |
| --- |
| OSAL |
| OS |
| HAL |
| 펌웨어 |
| 하드웨어 |

관심사를 분리시키고, 인터페이스를 활용하며, 대체 가능성을 높이는 방향으로 유도

### 결론 및 느낀점
----
테스트를 하기 위해서는 경계를 잘 구분지어야 하며 가장 변동이 없을 만한 클래스에 의존하여 테스트를 짜야한다는 것이다
이것은 사실 지금까지 이 책을 관통하는 주제의식과도 같은 건데 
변동성이 높은 코드는 변동성이 가장 낮은 코드에 의존하며 이를 통해 기획이나 비즈니스가 변동하더라도 변동이 쉬워야 한다.
특히 db나 os gui와 같은 변동이나 환경이 변화할 수 있는 것들에 의존하게 되면 우리는
변동하지 않아도 되는 비즈니스 모델까지 다시 코딩을 해야하는 상황에 이르게 될 수 있다.
이런 것은 좋은 코드는 아니며 우리에게 많은 생각을 하게 해준다. 
사실 처음에는 orm과 코드 그리고 http 네트워크를 어떻게 비즈니스에서 땔 수 있지?
라는 의구심이 들었으나 분리시키는 것이 올바르다고 생각하며 이를 적용하기 위한 방법론은 차차 구상해 가면 될 것이다.
방법론은 사실 중요하지 않다 그 속에 담긴 의미가 이 코드가 지향하는 방향이 어디로 흘러가고 있는 지를 항상 생각한다면
더 좋은 프로그래머로 성장 할 수 있을 것이라 생각한다.
