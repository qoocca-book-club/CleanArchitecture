### 험블객체 패턴

- 디자인 패턴으로 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안.
- 행위들을 두 개의 모듈 또는 클래스로 나눈다. 이들 모듈 중 하나가 험블이다.
- 뷰와 프레젠터라는 서로 다른 클래스로 만들 수 있다.
- 테스트 용이성을 가진 패턴
- 테스트하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하여 테스트 용이성을 가진 패턴

뷰는 험블 객체이고 테스트하기 어렵다. 뷰는 데이터를 GUI로 이동시키지만, 데이터를 직접 처리하지는 않는다. (보잘것 없는 객체)

프레젠터는 테스트하기 쉬운 객체다. 프레젠터의 역할은 어플리케이션으로부터 데이터를 받아 화면에 표현할 수 있는 포맷으로 만드는 것이다.

### 데이터베이스 게이트웨이

- 유스케이스 인터랙터와 데이터베이스 사이에는 데이터베이스 게이트웨이가 위치한다.
- 이 게이트웨이는 다형적 인터페이스로 애플리케이션이 데이터베이스에 수행하는 생성, 조회, 생신, 삭제 작업과 관련된 모든 매서드를 포함한다.

### 데이터 매퍼

하이버네이트 같은 ORM은 어느 계층에 속한다고 보는가?

객체와 달리 데이터 구조는 함축된 행위를 가지지 않는 public 데이터 변수의 집합이다.

ORM(객체 관계 매퍼)은 데이터베이스 계층이다. (사실 데이처 매퍼라고 부르는 편이 더 나을 수도 있다.)

실제로 ORM은 게이트웨이 인터페이스와 데이터베이스 사이에서 일종의 또 다른 험블 객체 경계를 형성한다.

### 서비스 리스너

어플리케이션이 다른 서비스와 반드시 통신해야 한다면, 어플리케이션에서 일련의 서비스를 제공해야 한다면, 우리는 여기에서 험블 객체 패턴을 발견할 수 있다.

- 어플리케이션은 데이터를 간단한 데이터 구조 형채로 로드한 후, 이 데이터 구조를 경계를 가로질러서 특정 모듈로 전달한다.
- 해당 모듈은 데이터를 적절한 포맷으로 만들어서 외부 서비스로 전송한다.
- 외부로부터 데이터를 수신하는 서비스의 경우, 서비스 리스너가 서비스 인터페이스로부터 데이터를 수신하고 데이터를 어플리케이션에서 사용할 수 있게 간단한 데이터 구조로 포맷을 변경한다.
- 그런 후 이 데이터 구조는 서비스 경계를 가로질러서 내부로 전달된다.

### 부분적 경계를 생성하는 방법

- 독립적으롤 검파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아만 두는 것.

### Strategy 패턴

- 완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야하므로 쌍방향 boundary인터페이스를 사용

![IMG_8860](https://github.com/user-attachments/assets/2c89fe2f-c2c1-4e8e-928e-8d58c2698b96)


### 퍼사드 패턴

- 클라이언트가 직접 서비스 클래스에 접근 불가.

![IMG_8861](https://github.com/user-attachments/assets/23bf99d8-2604-4193-ba78-22ce7c3c0e3c)


<aside>
💡

프로젝트 초반에는 구현할 경계가 무엇인지와 무시할 경계가 무엇인지를 쉽게 결정할 수 없다. 시스템이 발전함에 따라 주의를 기울여야 한다. 경계를 필요할 수도 있는 부분에 주목하고 경계가 존재하지 않아 생기는 마찰의 어렴풋한 첫 조짐을 신중하게 관찰. 

첫 조짐을 보이는 시점이 되면 해당 경계를 구현하는 비용과 무시할 때 감수할 비용을 가늠해 본다. 그리고 결정된 사항을 자주 검토한다. 우리의 목표는 경계의 구현 비용이 그걸 무시해서 생기는 비용보다 적어지는 바로 그 변곡점에서 경계를 구현

</aside>

### 서비스 아키텍처?

- 시스템을 서비스들로 분리함으로써 얻게 되는 이점

→ 프로세서 내의 또는 네트워크 상의 공유자원 때문에 결합될 가능성이 여전히 존재 더욱이 서로 공유하는 데이터에 의해 이들 서비스는 강력하게 결합되어 버린다.

- 전담팀이 서비스를 소유하고 운영한다는 점

→ 대규모 엔터프라이즈 시스켐은 서비스 기반 시스템 외에도 모노리틱 시스템이나 컴포넌트 기반 시스템으로도 구축할 수 있다는 사실

→ 서비스는 확장 가능한 시스템을 구축하는 유일한 선택지가 아니다.

→ 서비스라고 해서 항상 독립적으로 개발하고, 배포하며 운영할 수 있는 것은 아니다. 

<aside>
💡

아키텍처의 경계가 서비스 사이에 있지 않다는 사실. 오히려 서비스를 관통하며 서비스를 컴포넌트 단위로 분할. 

서비스는 단 하나의 아키텍처 경계로 둘러싸인 단일 컴포넌트로 만들 수 있다. 혹은 여러 아키텍처 경계로 분리된 다수의 컴포넌트로 구성할 수도 있다. 드물게는 클라이언트와 서비스가 강하게 결합되어 아키텍처적으로 아무런 의미가 없을 때도 있다.

</aside>

### 결론 및 느낀점
-----
팩토리 패턴이나 퍼사드 패턴을 쓰고 있기는 했지만 이렇게 구분지어서 생각해본 적은 없었던 것 같다.
이런 점에서 나도 아직 아키텍처를 설계하는 부분이나 클래스와 클래스 간의 연관관계를 적립하는 일에 미숙하다는 것을 깨달았다. 
또한 언제 요즘 내가 항상 고민하는 지점이 바로 언제 아키텍처를 고민하고 도입하고 정하는 과정이 필요한 지에 대해서 인데 이번 장에서도 나타내고 있다 시피
그 때라는 것은 정해진 것은 아니며 이 또한 순전히 적정 기술의 도입과 같이 주관적이라는 점이다. 이런 부분에 대해서는 경험과 많은 코드를 보면서 생각을 하고
스스로의 주관을 세워가는 것이 중요해 보인다. 

프로젝트 초반에는 구현할 경계가 무엇인지와 무시할 경계가 무엇인지를 쉽게 결정할 수 없다. 시스템이 발전함에 따라 주의를 기울여야 한다. 경계를 필요할 수도 있는 부분에 주목하고 경계가 존재하지 않아 생기는 마찰의 어렴풋한 첫 조짐을 신중하게 관찰. 

현재 회사의 코드는 시스템이 발전했지만 그와 더불어 구조가 설립되지 않고 있다는 것이 문제인 것 같다. 한가지의 방법이 있는 것이 아니라 방법이 혼재되어 있고 그와 더불어 경계또한 마땅히 존재하지 않는다.
그러다보니 테스트가 어려워지고 코드를 변경할 부분도 알 지 못한다.
이런 점을 개선해 나가기 위해 어떤 노력을 해야할 지 좀 더 고민해 보겠다.
