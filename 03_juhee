# 3부 설계 원칙

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다.

SOLID 원칙의 목적은 

- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

## SRP : 단일 책임 원칙

각 소프트웨어 모듈은 변경의 이유가 단 하나 여야만 한다.

<aside>
💡 퍼사드 패턴

퍼사드 패턴의 핵심 요소는 "퍼사드" 클래스입니다. 이 클래스는 시스템의 복잡한 부분을 캡슐화하고, 간단한 인터페이스를 제공하는 역할을 합니다. 클라이언트는 이 인터페이스를 사용하여 시스템의 서브시스템과 상호작용합니다.

</aside>

## OCP: 개방-폐쇄 원칙

기존 코드를 수정하기 보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계. 소프트웨어 개체의 행위는 확잘할 수 있어야 하지만, 이때 개체를 변경해서는 안된다. 

컴포넌트 계층구조를 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.

## LSP: 리스코프 치환 원칙

구성요소는 반드시 서로 치환 가능해야한다는 계약을 반드시 지켜야 한다.

상속 뿐만이 아니라 인터페이스에도 적용. 내가 어떤 구현체를 쓰고 있는 지 몰라야 한다.

## ISP: 인터페이스 분리 원칙

소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.

## DIP: 의존성 역전 원칙

세부사항이 정책에 의존해야한다.

의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.

- 변동성이 큰 구체 클래스를 참조하지 말라.
- 변동성이 큰 구체 클래스로 부터 파생하지 말라
- 구체 함수를 오버라이드 하지 말라
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.

# 느낀점
SOLID원칙은 자주 들어본 원칙이어서 그 내용은 알고 있었지만, 표면적으로 이해를 하고 있었던 것같다. 이 원칙이 어떤 의미를 가지고 있는지 깊게 이해하는 계기가 되었다.
결국 모든 SOLID 의 기조는 세부사항에 따라 코드가 급격하게 변하지 않아야 함에 초점을 맞추고 있다.
현실에서 여러 정책과 상황 시간 조건에 따라 세부적인 코드와 정책, 방법론은 바뀔 수 있다.
하지만 메인 도메인과 로직이 변경되는 경우는 찾아보기 어려울 것이다.
이런 상황에서 도메인이 세부 사항과 깊게 연관이 되면 변경되지 않아야 할 부분이 계속해서 변경이 될 수 있다는 것이다.
이런 코드는 분명 잘 짜여지지 못한 코드임에 틀림없다.
저자가 어떤 말을 하고 싶어하는 지 알 수 있었던 장이었다.
