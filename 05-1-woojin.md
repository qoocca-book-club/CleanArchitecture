# 5부 아키텍처

### 정리
##### 15장 아키텍트
아키텍처의 목ㅈ덕은 시스템의 생명주기를 지원
좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고 쉽게 배포해주는 것
아키텍처의 목표는 비용은 최소화하고 생산성은 최대화 하는 것
개발 : 시스템을 쉽게 개발할 수 있도록 뒷받침 해야함
배포 : 시스템을 단 한 번에 쉽게 배포할 수 있도록 만들어야 함
운영 : 시스템을 운영하는데 필요한 요구도 알려줌
유지보수 : 탐사와 위험부담 비용을 크게 줄일 수 있어야함
선택사항 열어 두기 : 선택사항을 가능한 한 많이, 오랫동안 열어 두는 것
- 좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다.
장치 독립성 : 장치에 종속되지 않게 해야 함

##### 16장 독립성
유스케이스 : 시스템의 의도를 지원해야 함
운영 : 아키텍처는 더 실질적이며 덜 파상적인 역할을 맡아야 함
개발 : 콘웨이의 법칙-시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한
구조의 설계를 만들어 낼 것이다.
배포 : 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.
선택사항 열어놓기 : 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있어야 함
계층결합분리 : 아키텍트는 시스템의 나머지 부분으로부터 분리하여 독립적으로 변경할 수 있어야 함
유스케이스 결합 분리 : 유스케이스들이 각 계층에서 겹치지 않게 함
개발,배포 독립성
중복 : 중복으로 보이는 두 코드 영역이 각자의 길로 간다면 중복이 아니므로 진짜 중복인지 확인해야 함

##### 17장 경계 : 선긋기
경계 : 소프트웨어 아키텍처의 선을 긋는 기술
좋은 시스템 아키텍처는 결정이 부수적이며, 결정을 연기할 수 있는 아키텍처
경계선을 긋는 행위는 결정을 늦추고 연기하는 데 도움이 되어 시간 절약을 할 수있음
선은 관련이 있는 것과 없는 것 사이에 그어야 한다.

##### 18장 경계 해부학
시스템 아키텍처는 소프트웨어 컴포넌트와 그 컴포넌트들을 분리하는 경계에 의해 정의된다.
경계 횡단하기 : 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일
배포형 컴포넌트 : 따로 컴파일 하지 않고 바로 사용 가능한 것
스레드 : 실행 계획과 순서르 체계화 하는 방법
로컬 프로세스 : 정적으로 링크된 단일체이거나 동적으로 링크된 여러개의 컴포넌트
서비스 : 물리적인 형태를 띠는 가장 강력한 경계, 저수준 서비스는 반드시 고수준 서비스에 플러그인 되어야 함

##### 19장 정책과 수준
수준 : 입력과 출력까지의 거리, 멀리 위치할수록 정책의 수준은 높아진다.
모든 소스 코드 의존성의 방향이 고수준 정책을 향할 수 있도록 정책을 분리하면 변경의 영향도를 줄일 수 있다.


### 결론
좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고,
정책이 세붛사항과 결합되지 않도록 엄격하게 분리한다.
시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며,
뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리 없이 반영 할 수 있도록 만들어야 한다.
소프트웨어 아키텍처에서 경계선을 그리려면 시스템을 컴포넌트 단위로 분할해야 함
그 후 컴포넌트 사이의 화살표가 특정방향, 핵심 업무를 향하도록 컴포넌트 소스를 배치한다.
단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.



----------------------------------------------------------------
