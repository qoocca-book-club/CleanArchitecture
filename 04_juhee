# 4부 컴포넌트 원칙

컴포넌트는 배포 단위 이다.

자바의 경우 jar 파일이 컴포넌트.

소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어.

→ 지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정

→ 이러다보니까 링킹 로더가 너무 커져서 링크와 로드 두 단계로 분리.

→ 컴퓨터가 빨라져서 로드와 링크를 동시에 할 수 있게 되었다. 

## 컴포넌트 응집도

### REP: 재사용/릴리스 등가 원칙

재사용 단위는 릴리스 단위와 같다.

하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야 한다는 사실은 컴포넌트 제작자 입장이나 사용자 입장에서도 이치에 맞는 얘기다.

### CCP: 공통 폐쇄 원칙

동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리. SRP와의 유사성.

### CRP: 공통 재사용 원칙

강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 된다고 말한다.

ISP는 사용하지 않은 매서드가 있는 클래스에 의존하지 말라

CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라

## 컴포넌트 사이의 관계

### ADP: 의존성 비순환 원칙

> 컴포넌트 의존성 그래프에 순환이 있어서는 안된다.

컴포넌트 사이의 순환을 끊고 의존성을 다시 DAG로 원상 복구하는 일 → DIP적용

의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일이다. 

### SDP: 안정된 의존성 원칙

> 안정성의 방향으로 더 안정된 쪽에 의존하라

안정적이라는 말은 변화가 발생하는 빈도와는 직접적인 관련이 없다, 안정성은 변경을 만들기 위해 필요한 작업량과 관련된다. 

소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다. 컴포넌트 안쪽으로 들어오는 의존성이 많아지만 상당히 안정적.

- Fan-in : 안으로 들어오는 의존성. 이 지표는 컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래스 개수
- Fan-out : 바깥으로 나가는 의존성. 이 지표는 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 개수
- 불안정성 :  I = Fan-out / (Fan-in + Fan-out). 이 지표는 [0,1] 범위의 값을 갖는다. I = 0이면 최고로 안정된 컴포넌트라는 뜻, I = 1이면 최고로 불안정한 컴포넌트라는 뜻

자신에게 의존하는 컴포넌트가 없으므로, 이 컴포넌트는 변경하지 말하야 할 이유가 없다. 반대로 이 컴포넌트가 다른 컴포넌트에 의존한다는 사실은 언젠가는 해당 컴포넌트를 변경해야 할 이유가 있다.  

### SAP: 안정된 추상화 원칙

> 컴포넌트는 안정된 정도만큼만 추상화 시켜야 한다.

안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다고 말한다.

안정성과 추상화 정도 사이의 관계

- 고통의 구역(0,0) : 매우 안정적이며 구체적 → 너무 뻣뻣한 상태
    - 추상적이지 않으므로 확장할 수 없고, 안정적이므로 변경하기도 상당히 어렵다.
    - 변동성이 없는 컴포넌트는 (0,0)애 위치했더라도 해롭지 않다.
    - 변동성이 크면 클수록 고통의 구역에 있기 어렵다.
- 쓸모 없는 구역(1,1): 최고로 추상적이지만 누구도 이 컴포넌트에 의존하지 않음.

주계열과의 거리 살피기


# 4부를 읽고 느낀 점
> 안정적이라는 말은 변화가 발생하는 빈도와는 직접적인 관련이 없다, 안정성은 변경을 만들기 위해 필요한 작업량과 관련된다.
이 말이 특히나 와 닿았다. 무조건 적으로 변경이 좋지 않다는 생각. 오래 가는 코드를 짜야 겠다는 생각은 오히려 좋은 코드와 멀어지는 길 일 수도 있다.
안정성은 변경을 얼마나 최소화 하는 지와 관련이 있다. 어떤 기획적인 부분이 추가가 되었을 때, 변경이 되었을 때 변화의 흐름을 적게 가져 가는 방안으로 코드를 짜야 할 것이다.
한 서비스와 서비스의 흐름 사이에 인터페이스를 만들어 추상화를 시키게 되면 의존성 역전이 발생하여 독립성을 가지게 된다.
클린 코드가 좋다. 아키텍처를 고민해봐야 한다는 말이 예전에는 굉장히 추상적으로 들렸는데 코드를 짜고 고민을 하게 되면서 어떤 방향으로 나아가야 하는 지에 대한 고민이 더 많아진 것 같다.
